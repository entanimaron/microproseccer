/* Do not remove the following line. Do not remove interrupt_handler(). */
#include "crt0.c"
#include "ChrFont0.h"

void lcd_init();
void lcd_sync_vbuf();
void lcd_clear_vbuf();
void lcd_putc(int y, int x, int c);
void handle_keypad_input();
void draw_input_formula();
int keypad_scan();


/* ===== 状態 ===== */
#define INIT 0
#define PLAY 1
int state = INIT;

/* ===== デバイス ===== */
volatile int *rot_enc = (int *)0xff14;
volatile int *led_ptr = (int *)0xff08;

/* ===== プレイヤー & 障害物 ===== */
int player_y = 3;
int obstacle_x = 11;
int obstacle_y = 3;
int obstacle_value = 12;   // 今流れている数字（例）
int obstacle_alive = 1;

int input_product = 1;    // 入力中の掛け算結果
int input_len = 0;

char input_str[16];       // "2x2x3" 表示用


/* ===== 割り込み (100msごと) ===== */
void interrupt_handler() {

    handle_keypad_input();   // ✅ 素因数入力処理

    if (obstacle_alive) {
        obstacle_x--;

        if (obstacle_x < 0) {
            obstacle_x = 11;
            obstacle_value = 12;  // 例として12固定
            obstacle_alive = 1;
        }
    }

    lcd_clear_vbuf();

    /* プレイヤー描画 */
    lcd_putc(player_y, 0, 'O');

    /* 障害物の数字描画 */
    if (obstacle_alive) {
        lcd_putc(2, obstacle_x, '1');
        lcd_putc(2, obstacle_x + 1, '2');  // ← 仮で12固定
    }

    /* 入力された式の表示 */
    draw_input_formula();

    lcd_sync_vbuf();
}


/* ===== メイン ===== */
void main() {
	while (1) {
		if (state == INIT) {
			lcd_init();
			state = PLAY;
		}
	}
}

void handle_keypad_input() {
    static int prev_key = -1;
    int key = keypad_scan();

    if (key == prev_key) return;  // 押しっぱなし防止
    prev_key = key;

    if (key == -1) return;

    /* ===== 数字キー（素因数）===== */
    if (key >= 2 && key <= 9) {
        input_product *= key;

        input_str[input_len++] = '0' + key;
        input_str[input_len]   = 0;
    }

    /* ===== Dキー → 掛け算記号 ===== */
    if (key == 13) {   // Dキー
        input_str[input_len++] = 'x';
        input_str[input_len]   = 0;
    }

    /* ===== Aキー → 判定 ===== */
    if (key == 10) {   // Aキー
        if (input_product == obstacle_value) {
            obstacle_alive = 0;  // ✅ 数字消滅（撃破）
        }

        // 入力リセット
        input_product = 1;
        input_len = 0;
        input_str[0] = 0;
    }

    /* ===== Bキー → 全消去 ===== */
    if (key == 11) {
        input_product = 1;
        input_len = 0;
        input_str[0] = 0;
    }
}



/*
 * ================= LCD関数群（変更不要） =================
 */
unsigned char lcd_vbuf[64][96];

void lcd_wait(int n) {
	for (int i = 0; i < n; i++);
}

void lcd_cmd(unsigned char cmd) {
	volatile int *lcd_ptr = (int *)0xff0c;
	*lcd_ptr = cmd;
	lcd_wait(1000);
}

void lcd_data(unsigned char data) {
	volatile int *lcd_ptr = (int *)0xff0c;
	*lcd_ptr = 0x100 | data;
	lcd_wait(200);
}

void lcd_pwr_on() {
	volatile int *lcd_ptr = (int *)0xff0c;
	*lcd_ptr = 0x200;
	lcd_wait(700000);
}

void lcd_init() {
	lcd_pwr_on();
	lcd_cmd(0xa0);
	lcd_cmd(0x20);
	lcd_cmd(0x15);
	lcd_cmd(0);
	lcd_cmd(95);
	lcd_cmd(0x75);
	lcd_cmd(0);
	lcd_cmd(63);
	lcd_cmd(0xaf);
}

void lcd_set_vbuf_pixel(int row, int col, int r, int g, int b) {
	r >>= 5; g >>= 5; b >>= 6;
	lcd_vbuf[row][col] = ((r << 5) | (g << 2) | (b << 0)) & 0xff;
}

void lcd_clear_vbuf() {
	for (int row = 0; row < 64; row++)
		for (int col = 0; col < 96; col++)
			lcd_vbuf[row][col] = 0;
}

void lcd_sync_vbuf() {
	for (int row = 0; row < 64; row++)
		for (int col = 0; col < 96; col++)
			lcd_data(lcd_vbuf[row][col]);
}

void lcd_putc(int y, int x, int c) {
	for (int v = 0; v < 8; v++)
		for (int h = 0; h < 8; h++)
			if ((font8x8[(c - 0x20) * 8 + h] >> v) & 0x01)
				lcd_set_vbuf_pixel(y * 8 + v, x * 8 + h, 0, 255, 0);
}

void draw_input_formula() {
    for(int i = 0; i < input_len; i++) {
        lcd_putc(7, i, input_str[i]);
    }
}

#define ADDR_KEYPAD ((volatile int *)0xff18)

int keypad_scan() {
    const int key_map[4][4] = {
        { 13, 14, 15, 16},
        { 12,  9,  8,  7},
        { 11,  6,  5,  4},
        { 10,  3,  2,  1}
    };

    int scan_pattern[4] = {0xE, 0xD, 0xB, 0x7}; 
    
    for (int col = 0; col < 4; col++) {
        *ADDR_KEYPAD = scan_pattern[col];

        for(volatile int w=0; w<100; w++);

        int input_data = *ADDR_KEYPAD;
        int rows = input_data & 0xF;

        if ((rows & 0x1) == 0) return key_map[col][0];
        if ((rows & 0x2) == 0) return key_map[col][1];
        if ((rows & 0x4) == 0) return key_map[col][2];
        if ((rows & 0x8) == 0) return key_map[col][3];
    }
    return -1;
}
